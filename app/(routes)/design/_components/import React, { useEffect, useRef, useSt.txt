import React, { useEffect, useRef, useState } from 'react'
import * as THREE from 'three'

interface ThreeDModelPreviewProps {
    canvasRef: React.RefObject<HTMLCanvasElement>
    designInfo?: {
        width: number
        height: number
        name: string
    }
    modelUrl?: string
}

const ThreeDModelPreview: React.FC<ThreeDModelPreviewProps> = ({
    canvasRef,
    designInfo,
    modelUrl = '/models/t-shirt.glb'
}) => {
    const previewRef = useRef<HTMLCanvasElement>(null)
    const sceneRef = useRef<THREE.Scene | null>(null)
    const rendererRef = useRef<THREE.WebGLRenderer | null>(null)
    const cameraRef = useRef<THREE.PerspectiveCamera | null>(null)
    const modelRef = useRef<THREE.Group | null>(null)
    const [texture, setTexture] = useState<THREE.CanvasTexture | null>(null)
    const [isModelLoaded, setIsModelLoaded] = useState(false)
    const [loadingProgress, setLoadingProgress] = useState(0)
    const [isLoading, setIsLoading] = useState(true)


    // Load 3D model
    useEffect(() => {
        if (!previewRef.current || !modelUrl) return

        const loadModel = async () => {
            try {
                // Try to load GLTFLoader and DRACOLoader dynamically
                let GLTFLoader: any = null;
                let DRACOLoader: any = null;

                try {
                    // Try addons path first
                    const gltfModule = await import('three/addons/loaders/GLTFLoader.js');
                    const dracoModule = await import('three/addons/loaders/DRACOLoader.js');
                    GLTFLoader = gltfModule.GLTFLoader;
                    DRACOLoader = dracoModule.DRACOLoader;
                } catch (error) {
                    console.log('Addons path failed, trying examples path:', error);
                    try {
                        // Try examples path
                        const gltfModule = await import('three/examples/jsm/loaders/GLTFLoader.js');
                        const dracoModule = await import('three/examples/jsm/loaders/DRACOLoader.js');
                        GLTFLoader = gltfModule.GLTFLoader;
                        DRACOLoader = dracoModule.DRACOLoader;
                    } catch (error2) {
                        console.log('Examples path also failed, using fallback:', error2);
                        createFallbackScene();
                        return;
                    }
                }

                if (GLTFLoader && DRACOLoader) {
                    const loader = new GLTFLoader();

                    // Setup DRACO loader for compressed models
                    const dracoLoader = new DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                    loader.setDRACOLoader(dracoLoader);

                    loader.load(
                        modelUrl,
                        (gltf: any) => {
                            setupSceneWithModel(gltf.scene);
                            // Clean up DRACO loader
                            dracoLoader.dispose();
                        },
                        (xhr: any) => {
                            setLoadingProgress((xhr.loaded / (xhr.total || 1000000)) * 100);
                        },
                        (error: any) => {
                            console.error('Error loading GLB model:', error);
                            // Try without DRACO as fallback
                            tryWithoutDraco(loader);
                        }
                    );
                }
            } catch (error) {
                console.error('Error in model loading process:', error);
                createFallbackScene();
            }
        };

        const tryWithoutDraco = (loader: any) => {
            // Try loading without DRACO (for non-compressed models)
            loader.setDRACOLoader(null);
            loader.load(
                modelUrl,
                (gltf: any) => {
                    setupSceneWithModel(gltf.scene);
                },
                (xhr: any) => {
                    setLoadingProgress((xhr.loaded / (xhr.total || 1000000)) * 100);
                },
                (error: any) => {
                    console.error('Error loading model without DRACO:', error);
                    createFallbackScene();
                }
            );
        };

        loadModel();
    }, [modelUrl]);

    const createFallbackScene = () => {
        if (!previewRef.current) return;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);
        sceneRef.current = scene;

        // Camera
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.z = 2;
        cameraRef.current = camera;

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: previewRef.current,
            antialias: true,
            alpha: true
        });
        renderer.setSize(200, 200);
        renderer.setPixelRatio(window.devicePixelRatio);
        rendererRef.current = renderer;

        // Create a simple plane as fallback
        const geometry = new THREE.PlaneGeometry(3, 3);
        const material = new THREE.MeshPhongMaterial({
            color: 0xdddddd,
            side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);
        modelRef.current = plane;

        // Setup lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        setIsModelLoaded(true);
        setIsLoading(false);
        setLoadingProgress(100);

        setupOrbitControls();
        startAnimationLoop(renderer, scene, camera);
    };

    const setupSceneWithModel = (model: THREE.Group) => {
        if (!previewRef.current) return;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);
        sceneRef.current = scene;

        // Camera
        const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        camera.position.z = 2;
        cameraRef.current = camera;

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: previewRef.current,
            antialias: true,
            alpha: true
        });
        renderer.setSize(200, 200);
        renderer.setPixelRatio(window.devicePixelRatio);
        rendererRef.current = renderer;

        // Add loaded model to scene
        scene.add(model);
        modelRef.current = model;

        // Center and scale model
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 1.5 / maxDim;

        model.scale.setScalar(scale);
        model.position.sub(center.multiplyScalar(scale));

        // Setup lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Add additional lights for better visibility
        const fillLight = new THREE.DirectionalLight(0x777777, 0.3);
        fillLight.position.set(-1, -1, -1);
        scene.add(fillLight);

        setIsModelLoaded(true);
        setIsLoading(false);
        setLoadingProgress(100);

        setupOrbitControls();
        startAnimationLoop(renderer, scene, camera);
    };

    const setupOrbitControls = () => {
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        const onMouseDown = (e: MouseEvent) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        };

        const onMouseMove = (e: MouseEvent) => {
            if (!isDragging || !modelRef.current) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            modelRef.current.rotation.y += deltaX * 0.01;
            modelRef.current.rotation.x += deltaY * 0.01;

            previousMousePosition = { x: e.clientX, y: e.clientY };
        };

        const onMouseUp = () => {
            isDragging = false;
        };

        const onWheel = (e: WheelEvent) => {
            if (cameraRef.current) {
                cameraRef.current.position.z += e.deltaY * 0.01;
                cameraRef.current.position.z = Math.max(1, Math.min(5, cameraRef.current.position.z));
            }
        };

        if (previewRef.current) {
            previewRef.current.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            previewRef.current.addEventListener('wheel', onWheel);
        }

        return () => {
            if (previewRef.current) {
                previewRef.current.removeEventListener('mousedown', onMouseDown);
                previewRef.current.removeEventListener('wheel', onWheel);
            }
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
        };
    };

    const startAnimationLoop = (renderer: THREE.WebGLRenderer, scene: THREE.Scene, camera: THREE.PerspectiveCamera) => {
        const animate = () => {
            requestAnimationFrame(animate);
            if (modelRef.current) {
                modelRef.current.rotation.y += 0.005;
            }
            renderer.render(scene, camera);
        };
        animate();
    };

    // Apply design texture to model
    useEffect(() => {
        if (!isModelLoaded || !modelRef.current || !canvasRef?.current) return;

        const applyTextureToModel = () => {
            try {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const newTexture = new THREE.CanvasTexture(canvas);
                newTexture.needsUpdate = true;

                // Apply texture to model
                if (modelRef.current) {
                    modelRef.current.traverse((child) => {
                        if (child instanceof THREE.Mesh && child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => {
                                    if (mat instanceof THREE.MeshStandardMaterial || mat instanceof THREE.MeshPhongMaterial) {
                                        mat.map = newTexture;
                                        mat.needsUpdate = true;
                                    }
                                });
                            } else if (child.material instanceof THREE.MeshStandardMaterial || child.material instanceof THREE.MeshPhongMaterial) {
                                child.material.map = newTexture;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                }

                if (texture) texture.dispose();
                setTexture(newTexture);

            } catch (error) {
                console.error('Error applying texture:', error);
            }
        };

        applyTextureToModel();
        const interval = setInterval(applyTextureToModel, 1000);

        return () => clearInterval(interval);
    }, [isModelLoaded, canvasRef]);

    return (
        <div className= 'absolute bottom-10 right-10 bg-white p-3 rounded-xl shadow-2xl border border-gray-200' >
        <div className="flex items-center justify-between mb-3" >
            <h3 className="text-sm font-semibold text-gray-800" > 3D Preview </h3>
    {
        isLoading ? (
            <div className= "text-xs text-blue-500" > { Math.round(loadingProgress) } % </div>
                ) : (
    <div className= "w-2 h-2 bg-green-500 rounded-full animate-pulse" > </div>
                )}
</div>

    < div className = "relative" >
        <canvas
                    ref={ previewRef }
className = "block rounded-lg border border-gray-300 cursor-grab active:cursor-grabbing"
style = {{ width: '200px', height: '200px' }}
                />

{
    isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-100 bg-opacity-80 rounded-lg" >
            <div className="text-center" >
                <div className="w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto" > </div>
                    < p className = "text-xs text-gray-600 mt-2" > Loading model...</p>
                        </div>
                        </div>
                )
}
</div>

    < div className = "mt-2 text-xs text-gray-500 text-center" >
    {
        designInfo?(
                    <span> { designInfo.name } • { designInfo.width }×{ designInfo.height } </span>
                ) : (
    <span>Drag to rotate • Scroll to zoom </span>
                )}
</div>

    < div className = "mt-2 flex justify-center space-x-1" >
        <button
                    className="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors"
onClick = {() => {
    if (modelRef.current) {
        modelRef.current.rotation.x += Math.PI / 2;
    }
}}
                >
    Flip
    </button>
    < button
className = "text-xs px-2 py-1 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors"
onClick = {() => {
    if (cameraRef.current && modelRef.current) {
        cameraRef.current.position.set(0, 0, 2);
        modelRef.current.rotation.set(0, 0, 0);
    }
}}
                >
    Reset
    </button>
    </div>
    </div>
    );
};

export default ThreeDModelPreview;